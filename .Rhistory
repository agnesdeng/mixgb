devtools::check_rhub()
devtools::check()
usethis::use_github_action()
devtools::release()
devtools::build()
devtools::load_all()
devtools::document()
getwd
getwd()
imputed.data <- mixgb(data = nhanes3_newborn, m = 5,save.models = TRUE,save.models.folder= "/Users/agnes/Desktop/mixgb/notes/models" )
imputed.data
mixgb_obj<- mixgb(data = nhanes3_newborn, m = 5,save.models = TRUE,save.models.folder= "/Users/agnes/Desktop/mixgb/notes/models" )
mixgb_obj
mixgb_obj
mixgb_obj$XGB.models
data = nhanes3_newborn
m = 5
maxit =5
save.models = TRUE
save.vars = NULL
save.models.folder= "/Users/agnes/Desktop/mixgb/notes/models"
pmm.type = NULL
pmm.k = 5
pmm.link = "prob"
initial.num = "normal"
initial.int = "mode"
initial.fac = "mode"
verbose = F
xgb.params = list()
nrounds = 100
early_stopping_rounds = NULL
print_every_n = 10L
xgboost_verbose = 0
if (!(is.data.frame(data) || is.matrix(data))) {
stop("Data need to be a data frame or a matrix.")
}
if (!is.data.table(data)) {
data <- as.data.table(data)
}
# check whether to use xgb.save()
if (!is.null(save.models.folder)) {
if (!dir.exists(save.models.folder)) {
dir.create(file.path(save.models.folder), recursive = TRUE)
}
save.models <- TRUE
XGB.save <- TRUE
} else if(save.models) {
warnings("Models are saved in the environment. Suggest specifing the directory in save.models.folder")
XGB.save<-FALSE
}
# Get the current version of XGBoost as a 'package_version' object
xgboost.version <- packageVersion("xgboost")
# Define the minimum required version as a 'package_version' object
required.version <- package_version("2.0.0")
# Use relational operators to compare version objects
if (xgboost.version >= required.version) {
# for XGBoost 2.0.0 or newer
xgb.params <- do.call("default_params", xgb.params)
} else {
# Code for older versions of XGBoost
xgb.params <- do.call("default_params_cran", xgb.params)
}
if (ordinalAsInteger == TRUE) {
if (is.null(pmm.type)) {
ordinalAsInteger <- FALSE
warning(" `ordinalAsInteger` will be coerced to FALSE when `pmm.type = NULL`")
}
ord.fac <- names(Filter(is.ordered, data))
if (length(ord.fac) > 0) {
data[, c(ord.fac) := lapply(.SD, fac2int), .SDcols = ord.fac]
}
}
ordinalAsInteger = FALSE
if (ordinalAsInteger == TRUE) {
if (is.null(pmm.type)) {
ordinalAsInteger <- FALSE
warning(" `ordinalAsInteger` will be coerced to FALSE when `pmm.type = NULL`")
}
ord.fac <- names(Filter(is.ordered, data))
if (length(ord.fac) > 0) {
data[, c(ord.fac) := lapply(.SD, fac2int), .SDcols = ord.fac]
}
}
# initial imputation
Ncol <- ncol(data)
if (Ncol < 2) {
stop("Data need to have a least two columns.")
}
Nrow <- nrow(data)
## Data preprocessing
# 1) sort the dataset with increasing NAs
origin.names <- copy(colnames(data))
# Calculate the number of NAs per column directly within the data.table framework
na_counts <- data[, lapply(.SD, function(col) sum(is.na(col)))]
# Order columns by their NA counts
na_vector <- unlist(na_counts, use.names = TRUE)
sorted.idx <- order(na_vector)
# Get sorted column names
sorted.names <- names(na_counts)[sorted.idx]
all.idx<-1:Ncol
names(all.idx)<-sorted.names
# data.table
# sorted.data <- data[, ..sorted.names]
# sorted.data <- data[, sorted.names, with = FALSE]
setcolorder(data, sorted.names)
sorted.types <- feature_type2(data)
cbind.types<-cbind_type(data)
if(all(cbind.types=="factor")){
matrix.method<-"cpp.factor"
}else if(all(cbind.types %in% c("numeric","integer"))){
matrix.method<-"as.matrix"
}else{
matrix.method<-"cpp.combo"
}
# 2)initial imputation & data validation
sorted.naSums <- na_counts[, sorted.names, with = FALSE]
missing.idx <- which(sorted.naSums != 0)
missing.vars <- sorted.names[missing.idx]
names(missing.idx)<-missing.vars
obs.vars<-sorted.names[-missing.idx]
missing.types <- sorted.types[missing.idx]
missing.method <- ifelse(missing.types == "numeric", initial.num,
ifelse(missing.types == "integer", initial.int, initial.fac)
)
if (all(sorted.naSums == 0)) {
stop("No missing values in this data frame.")
}
if (any(sorted.naSums == Nrow)) {
stop("At least one variable in the data frame has 100% missing values.")
}
if (any(sorted.naSums >= 0.9 * Nrow)) {
warning("Some variables have more than 90% miss entries.")
}
mp <- length(missing.vars)
Obs.idx <- vector("list", mp)
names(Obs.idx) <- missing.vars
Na.idx <- vector("list", mp)
names(Na.idx) <- missing.vars
Na.idx
for (var in missing.vars) {
na.idx <- which(is.na(data[[var]]))
Na.idx[[var]] <- na.idx
# Na.idx[[var]] <- data[, .I[is.na(get(var))], .SDcols = var]
if (missing.method[[var]] == "normal") {
# only works for numeric
var.mean <- mean(data[[var]], na.rm = TRUE)
var.sd <- sd(data[[var]], na.rm = TRUE)
set(data, i = na.idx, j = var, value = stats::rnorm(n = length(na.idx), mean = var.mean, sd = var.sd))
} else if (missing.method[[var]] == "mean") {
# only works for numeric
set(data, i = na.idx, j = var, value = mean(data[[var]], na.rm = TRUE))
} else if (missing.method[[var]] == "median") {
# only works for numeric
set(data, i = na.idx, j = var, value = median(data[[var]], na.rm = TRUE))
} else if (missing.method[[var]] == "mode") {
# work for both numeric (only recommend for integer type) and factor
unique.values <- unique(na.omit(data[[var]]))
tab <- tabulate(match(data[[var]], unique.values))
var.mode <- unique.values[tab == max(tab)]
if (length(var.mode) != 1) {
# if mode is not unique, impute with randomly sampled modes
var.mode <- sample(var.mode, size = length(na.idx), replace = TRUE)
}
set(data, i = na.idx, j = var, value = var.mode)
} else if (missing.method[[var]] == "sample") {
# work for both numeric (only recommend for integer type) and factor
set(data, i = na.idx, j = var, value = sample(data[[var]][!is.na(data[[var]])], size = length(na.idx), replace = TRUE))
} else {
stop("Please specify an acceptable initial imputation method.")
}
# To do: include initial imputation using models
# To do: if bootstrap, need a copy of the sorted data before initial imputation, will need more memory usage. Do it later
# if (bootstrap) {
# originally :  result$sortedNA.dt <- sort.result$sorted.dt
# }
}
check_pmm(pmm.type = pmm.type, xgb.params = xgb.params, Nrow = Nrow, sorted.naSums = sorted.naSums, sorted.types = sorted.types, pmm.k = pmm.k)
imputed.data <- vector("list", m)
Na.idx
i=1
sorted.dt <- copy(data)
j=1
sorted.dt <- mixgb_null(Obs.m=Obs.m, matrix.method=matrix.method, cbind.types=cbind.types,
pmm.type = pmm.type, pmm.link = pmm.link, pmm.k = pmm.k, yobs.list = yobs.list, yhatobs.list = yhatobs.list,
sorted.dt = sorted.dt, missing.vars = missing.vars, sorted.names = sorted.names,
Na.idx = Na.idx, missing.types = missing.types, Ncol = Ncol,
xgb.params = xgb.params,
nrounds = nrounds, early_stopping_rounds = early_stopping_rounds,
print_every_n = print_every_n, verbose = xgboost_verbose)
Obs.m
if (save.models == TRUE) {
extra.vars <- save_vars(save.vars = save.vars, origin.names = origin.names, missing.vars = missing.vars)
extra.types <- sorted.types[extra.vars]
save.vars <- c(missing.vars, extra.vars)
save.p <- length(save.vars)
# for each variable in save.vars, save its observed values for PMM
yobs.list <- vector("list", save.p)
names(yobs.list) <- save.vars
# variables with NAs
for (var in missing.vars) {
na.idx <- Na.idx[[var]]
# obs.y
yobs.list[[var]] <- data[[var]][-na.idx]
}
# variables fully observed
for (var in extra.vars) {
yobs.list[[var]] <- data[[var]]
}
} else {
# save.models=FALSE
extra.vars <- NULL
extra.types <- NULL
yobs.list <- vector("list", mp)
names(yobs.list) <- missing.vars
for (var in missing.vars) {
na.idx <- Na.idx[[var]]
# obs.y
yobs.list[[var]] <- data[[var]][-na.idx]
}
}
if(length(obs.vars)==0){
Obs.m<-NULL
}else{
if(matrix.method=="as.matrix"){
Obs.m<-as.matrix(data[,!missing.vars,with = FALSE])
}else{
Obs.list <- lapply(obs.vars, function(feature){
if(cbind.types[feature] %in% c("numeric","integer")){
as.matrix(data[[feature]])
} else if(cbind.types[feature] == "ordered"){
Matrix::t(fac2Sparse(data[[feature]], factorPatt12=c(T,F), contrasts.arg = "contr.poly")[[1]])
} else {
Matrix::t(fac2sparse(data[[feature]]))[, -1, drop = FALSE]
}
})
if(matrix.method=="cpp.combo"){
Obs.m<-cbind_combo(Obs.list )
}else if(matrix.method=="cpp.factor"){
Obs.m<-cbind_sparse_matrix(Obs.list )
}
}
}
yhatobs.list <- NULL
if (isTRUE(pmm.type == 1)) {
sorted.dt <- copy(data)
yhatobs.list <- save_yhatobs(Obs.m=Obs.m, matrix.method=matrix.method, cbind.types=cbind.types, all.idx=all.idx,
yobs.list = yobs.list, maxit = maxit, pmm.link = pmm.link, sorted.dt = sorted.dt, missing.vars = missing.vars, extra.vars = extra.vars, extra.types = extra.types, sorted.names = sorted.names, Na.idx = Na.idx, missing.types = missing.types, Ncol = Ncol,
xgb.params = xgb.params,
nrounds = nrounds, early_stopping_rounds = early_stopping_rounds, print_every_n = print_every_n, verbose = xgboost_verbose, ...
)
}
# save the model dir
XGB.models <- vector("list", m)
sorted.dt <- copy(data)
sorted.dt <- mixgb_null(Obs.m=Obs.m, matrix.method=matrix.method, cbind.types=cbind.types,
pmm.type = pmm.type, pmm.link = pmm.link, pmm.k = pmm.k, yobs.list = yobs.list, yhatobs.list = yhatobs.list,
sorted.dt = sorted.dt, missing.vars = missing.vars, sorted.names = sorted.names,
Na.idx = Na.idx, missing.types = missing.types, Ncol = Ncol,
xgb.params = xgb.params,
nrounds = nrounds, early_stopping_rounds = early_stopping_rounds, print_every_n = print_every_n, verbose = xgboost_verbose)
sorted.dt
print(sorted.dt)
Na.idx
sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
mean(sorted.dt[[col]][na.idx])
})
missing.types
sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-sorted.dt[[col]][na.idx]
if (is.factor(imp.vals) || is.character(vals)) {
# Calculate Proportion of the Mode
counts <- table(vals)
if (length(counts) == 0) return(NA) # Handle empty cases
max_count <- max(counts)
return(max_count / sum(counts))
} else {
# Default to Mean for numeric columns
return(mean(vals, na.rm = TRUE))
}
})
sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-sorted.dt[[col]][na.idx]
if (is.factor(vals) || is.character(vals)) {
# Calculate Proportion of the Mode
counts <- table(vals)
if (length(counts) == 0) return(NA) # Handle empty cases
max_count <- max(counts)
return(max_count / sum(counts))
} else {
# Default to Mean for numeric columns
return(mean(vals, na.rm = TRUE))
}
})
obj
missing.vars
Ncol
#for each m
imp.agg <- matrix(data=NA, nrow=maxit, ncol=length(missing.vars))
imp.agg
colnames(imp.agg)<-missing.vars
imp.agg
IMP.agg <- matrix(data=NA, nrow=maxit, ncol=length(missing.vars))
colnames(IMP.agg)<-missing.vars
IMP.agg
imp.agg<-sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-sorted.dt[[col]][na.idx]
if (is.factor(vals) || is.character(vals)) {
# Calculate Proportion of the Mode
counts <- table(vals)
if (length(counts) == 0) return(NA) # Handle empty cases
max_count <- max(counts)
return(max_count / sum(counts))
} else {
# Default to Mean for numeric columns
return(mean(vals, na.rm = TRUE))
}
})
IMP.agg[j,] <- imp.agg
IMP.agg
maxit
#for each m
IMP.agg <- matrix(data=NA, nrow=maxit, ncol=length(missing.vars))
colnames(IMP.agg)<-missing.vars
sorted.dt <- copy(data)
for (j in seq_len(maxit - 1)) {
# for j=1:(maxit-1)  only update the imputed dataset
sorted.dt <- mixgb_null(Obs.m=Obs.m, matrix.method=matrix.method, cbind.types=cbind.types,
pmm.type = pmm.type, pmm.link = pmm.link, pmm.k = pmm.k, yobs.list = yobs.list, yhatobs.list = yhatobs.list,
sorted.dt = sorted.dt, missing.vars = missing.vars, sorted.names = sorted.names,
Na.idx = Na.idx, missing.types = missing.types, Ncol = Ncol,
xgb.params = xgb.params,
nrounds = nrounds, early_stopping_rounds = early_stopping_rounds, print_every_n = print_every_n, verbose = xgboost_verbose
)
# mean of imputed values for numeric or the proportion of mode for factor
imp.agg<-sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-sorted.dt[[col]][na.idx]
if (is.factor(vals) || is.character(vals)) {
# Calculate Proportion of the Mode
counts <- table(vals)
if (length(counts) == 0) return(NA) # Handle empty cases
max_count <- max(counts)
return(max_count / sum(counts))
} else {
# Default to Mean for numeric columns
return(mean(vals, na.rm = TRUE))
}
})
IMP.agg[j,] <- imp.agg
}
IMP.agg
maxit=5
sorted.dt <- copy(data)
#for each m
IMP.agg <- matrix(data=NA, nrow=maxit, ncol=length(missing.vars))
colnames(IMP.agg)<-missing.vars
for (j in seq_len(maxit - 1)) {
# for j=1:(maxit-1)  only update the imputed dataset
sorted.dt <- mixgb_null(Obs.m=Obs.m, matrix.method=matrix.method, cbind.types=cbind.types,
pmm.type = pmm.type, pmm.link = pmm.link, pmm.k = pmm.k, yobs.list = yobs.list, yhatobs.list = yhatobs.list,
sorted.dt = sorted.dt, missing.vars = missing.vars, sorted.names = sorted.names,
Na.idx = Na.idx, missing.types = missing.types, Ncol = Ncol,
xgb.params = xgb.params,
nrounds = nrounds, early_stopping_rounds = early_stopping_rounds, print_every_n = print_every_n, verbose = xgboost_verbose
)
# mean of imputed values for numeric or the proportion of mode for factor
imp.agg<-sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-sorted.dt[[col]][na.idx]
if (is.factor(vals)) {
vals<-as.integer(factor(vals, levels = levels(sorted.dt[[col]])))
}
return(mean(vals, na.rm = TRUE))
})
IMP.agg[j,] <- imp.agg
}
IMP.agg
sorted.dt <- copy(data)
#for each m
IMP.mean <- matrix(data=NA, nrow=maxit, ncol=length(missing.vars))
colnames(IMP.mean)<-missing.vars
for (j in seq_len(maxit - 1)) {
# for j=1:(maxit-1)  only update the imputed dataset
sorted.dt <- mixgb_null(Obs.m=Obs.m, matrix.method=matrix.method, cbind.types=cbind.types,
pmm.type = pmm.type, pmm.link = pmm.link, pmm.k = pmm.k, yobs.list = yobs.list, yhatobs.list = yhatobs.list,
sorted.dt = sorted.dt, missing.vars = missing.vars, sorted.names = sorted.names,
Na.idx = Na.idx, missing.types = missing.types, Ncol = Ncol,
xgb.params = xgb.params,
nrounds = nrounds, early_stopping_rounds = early_stopping_rounds, print_every_n = print_every_n, verbose = xgboost_verbose
)
# mean of imputed values for numeric or the proportion of mode for factor
imp.mean<-sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-sorted.dt[[col]][na.idx]
if (is.factor(vals)) {
vals<-as.integer(factor(vals, levels = levels(sorted.dt[[col]])))
}
return(mean(vals, na.rm = TRUE))
})
IMP.mean[j,] <- imp.mean
}
IMP.mean
imp.summary<-sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-sorted.dt[[col]][na.idx]
if (is.factor(vals)) {
vals<-as.integer(factor(vals, levels = levels(sorted.dt[[col]])))
}
c(mu=mean(vals, na.rm = TRUE),v = var(vals, na.rm = TRUE))
})
imp.summary
imp.summary["m",]
imp.summary
imp.summary[1,]
imp.summary["mu",]
imp.summary["v",]
sorted.dt <- copy(data)
#for each m
IMP.mean <- matrix(data=NA, nrow=maxit, ncol=length(missing.vars))
colnames(IMP.mean)<-missing.vars
IMP.var <- matrix(data=NA, nrow=maxit, ncol=length(missing.vars))
colnames(IMP.var)<-missing.vars
maxit=5
for (j in seq_len(maxit - 1)) {
# for j=1:(maxit-1)  only update the imputed dataset
sorted.dt <- mixgb_null(Obs.m=Obs.m, matrix.method=matrix.method, cbind.types=cbind.types,
pmm.type = pmm.type, pmm.link = pmm.link, pmm.k = pmm.k, yobs.list = yobs.list, yhatobs.list = yhatobs.list,
sorted.dt = sorted.dt, missing.vars = missing.vars, sorted.names = sorted.names,
Na.idx = Na.idx, missing.types = missing.types, Ncol = Ncol,
xgb.params = xgb.params,
nrounds = nrounds, early_stopping_rounds = early_stopping_rounds, print_every_n = print_every_n, verbose = xgboost_verbose
)
imp.summary<-sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-sorted.dt[[col]][na.idx]
if (is.factor(vals)) {
vals<-as.integer(factor(vals, levels = levels(sorted.dt[[col]])))
}
c(mu=mean(vals, na.rm = TRUE),v = var(vals, na.rm = TRUE))
})
# mean of imputed values
IMP.mean[j,] <- imp.summary["mu",]
# variance of imputed values
IMP.var[j, ] <- imp.summary["v",]
}
IMP.mean
IMP.var
saved.obj <- mixgb_xgb_save(Obs.m=Obs.m, matrix.method=matrix.method, cbind.types=cbind.types, all.idx,
save.models.folder = save.models.folder, i = i,
save.vars = save.vars, save.p = save.p, extra.vars = extra.vars, extra.types = extra.types, pmm.type = pmm.type, pmm.link = pmm.link, pmm.k = pmm.k,
yobs.list = yobs.list, yhatobs.list = yhatobs.list, sorted.dt = sorted.dt, missing.vars = missing.vars, sorted.names = sorted.names,
Na.idx = Na.idx, missing.types = missing.types, Ncol = Ncol,
xgb.params = xgb.params,
nrounds = nrounds, early_stopping_rounds = early_stopping_rounds, print_every_n = print_every_n, verbose = xgboost_verbose
)
saved.obj
saved.obj$sorted.dt
imp.summary<-sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-saved.obj$sorted.dt[[col]][na.idx]
if (is.factor(vals)) {
vals<-as.integer(factor(vals, levels = levels(sorted.dt[[col]])))
}
c(mu=mean(vals, na.rm = TRUE),v = var(vals, na.rm = TRUE))
})
imp.summary
j
# mean of imputed values
IMP.mean[maxit,] <- imp.summary["mu",]
# variance of imputed values
IMP.var[maxit, ] <- imp.summary["v",]
IMP.mean
IMP.var
saved.obj <- mixgb_save(Obs.m=Obs.m, matrix.method=matrix.method, cbind.types=cbind.types, all.idx,
save.models.folder = save.models.folder, i = i,
save.vars = save.vars, save.p = save.p, extra.vars = extra.vars, extra.types = extra.types, pmm.type = pmm.type, pmm.link = pmm.link, pmm.k = pmm.k,
yobs.list = yobs.list, yhatobs.list = yhatobs.list, sorted.dt = sorted.dt, missing.vars = missing.vars, sorted.names = sorted.names,
Na.idx = Na.idx, missing.types = missing.types, Ncol = Ncol,
xgb.params = xgb.params,
nrounds = nrounds, early_stopping_rounds = early_stopping_rounds, print_every_n = print_every_n, verbose = xgboost_verbose
)
saved.obj$sorted.dt
imp.summary<-sapply(names(Na.idx),function(col){
na.idx<-Na.idx[[col]]
vals<-saved.obj$sorted.dt[[col]][na.idx]
if (is.factor(vals)) {
vals<-as.integer(factor(vals, levels = levels(sorted.dt[[col]])))
}
c(mu=mean(vals, na.rm = TRUE),v = var(vals, na.rm = TRUE))
})
# mean of imputed values
IMP.mean[maxit,] <- imp.summary["mu",]
# variance of imputed values
IMP.var[maxit, ] <- imp.summary["v",]
IMP.mean
IMO.var
IMP.var
devtools::load_all()
devtools::document()
mixgb_obj<- mixgb(data = nhanes3_newborn, m = 5, maxit=5, save.models = TRUE)
mixgb_obj
styler:::style_active_file()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
