---
title: "mixgb: Multiple Imputation Through XGBoost"
author: "Yongshi Deng"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mixgb: Multiple Imputation Through XGBoost}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

Mixgb offers a scalable solution for imputing large datasets using XGBoost, bootstrapping and predictive mean matching. Mixgb is built under Fully Conditional Specification (FCS), where XGBoost imputation models are built for each incomplete variable. Mixgb can automatically handle different types of variables and users do not need to encode categorical variables themselves. Users can also choose different settings regarding bootstrapping and the types predictive mean matching to enhance imputation performance.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Impute missing values with `mixgb`

We first load the `mixgb` package and the `nhanes3_newborn` dataset, which contains 16 variables of various types (integer/numeric/factor/ordinal factor). There are 9 variables with missing values.

```{r setup}
#devtools::load_all()
library(mixgb)
data(nhanes3_newborn)
str(nhanes3_newborn)
colSums(is.na(nhanes3_newborn))

#use mixgb with default settings
MIXGB <- Mixgb$new(data = nhanes3_newborn)
imputed.data <- MIXGB$impute(m = 5, maxit = 1)

```

To impute this dataset, first we need to set up an Mixgb imputer with our choice of settings or leave it as default. Note that we do not need to convert our data into dgCMatrix or one-hot coding format. Our package will convert it automatically. Variables should be of the following types: numeric, integer, factor or ordinal factor. Except `data`, other arguments in `Mixgb$new( )` are either hyperparameters or verbose settings for XGBoost training.

```{r}
#Set up mixgb imputer with chosen settings
params = list(max_depth = 6, 
              gamma = 0.1, 
              eta = 0.3, 
              min_child_weight = 1, 
              subsample = 1, 
              colsample_bytree = 1, 
              colsample_bylevel = 1, 
              colsample_bynode=1, 
              nthread = 4, 
              tree_method = "auto", 
              gpu_id = 0, 
              predictor = "auto")

MIXGB <- Mixgb$new(data = nhanes3_newborn, xgb.params = params, nrounds = 100, early_stopping_rounds = 1, print_every_n = 1, verbose = 0)
```

### Tune hyperparameters

Imputation performance can be affected by the hyperparameter settings. It may seem daunting to tune a large set of hyperparameters, but often we can narrow down the search as many hyperparameters are correlated. In our package, we have a function `mixgb_cv()` to tune `nrounds`. There is no default `nrounds` value in `XGBoost,` so we need to specify it. The default `nrounds` in `mixgb` is 50. However, we recommend using `mixgb_cv()` to find the optimal `nrounds` first.

```{r}
optimal.nrounds <- mixgb_cv(data = nhanes3_newborn, verbose = FALSE)
optimal.nrounds$evaluation.log
optimal.nrounds$response
optimal.nrounds$best.nrounds
```

By default, `mixgb_cv()` will randomly choose an incomplete variable as the response and build an XGBoost model with other variables using the complete cases of the dataset. Therefore, each run of `mixgb_cv()` is likely to return different results. Users can also specify the response and covariates in the argument `response` and `select_covariates`, respectively.

```{r}
optimal.nrounds <- mixgb_cv(data = nhanes3_newborn, nfold = 10, nrounds = 100, early_stopping_rounds = 1, response = "BMPHEAD", select_covariates = c("HSHSIZER","HSAGEIR", "HSSEX", "DMARETHN",          "BMPRECUM", "BMPSB1", "BMPSB2", "BMPTR1", "BMPTR2", "BMPWT", "DMPPIR", "HFF1", "HYD1"),verbose = FALSE)

optimal.nrounds$best.nrounds
```

Since the results returned by `mixgb_cv()` are mostly less than 20, I'll set `nrounds = 20` in the imputer. We now use this imputer to obtain m imputed datasets, which will be stored in a list of `m` data tables. If `m = 1`, single imputation will be undertaken. Users can also specify the number of imputation iterations `maxit`.

```{r}
MIXGB <- Mixgb$new(data = nhanes3_newborn, nrounds = 20)
imputed.data <- MIXGB$impute(m = 5, maxit = 1)
```

### Customise imputation settings

We can also customise other imputation settings:

-   Whether to use bootstrapping

-   The types of predictive mean matching

-   The number of donors for predictive mean matching

-   Whether to convert ordinal factors to integer (imputation process will be faster)

-   Initial imputation methods for different types of variables

```{r}
imputed.data <- MIXGB$impute(m = 5, maxit = 1,  bootstrap = TRUE,
                             pmm.type = "auto", pmm.k = 5, 
                             ordinalAsInteger = TRUE,
                             initial.num = "normal", initial.int = "sample", initial.fac = "mode")

```

#### Convert ordinal factors to integers

If our dataset has ordinal factors, then the imputation process will be sped up by converting them to integers. In `nhanes3_newborn` data, there is only one ordinal factor, but we can still see that the imputation time is smaller with `ordinalAsInteger = TRUE`. If `m` and `maxit` are larger, the difference will be even more obvious. Note that when `ordinalAsInteger = TRUE` , the class of these ordinal factors in the imputed datasets will also be integer. We recommend to use the default PMM setting `pmm.type = "auto"`, which will impute numeric and integer variables with PMM (type 2) and impute categorical variables without PMM. If we don't apply PMM to integer variables, the missing values may be imputed as numeric. Sometimes this can be problematic, especially when the integers are actually converted from ordinal factors. Therefore, `pmm.type = NULL` is disabled when `ordinalAsInteger = TRUE` .

```{r}
system.time(imputed.data <- MIXGB$impute(m = 5, maxit = 1,ordinalAsInteger = FALSE))

system.time(imputed.data <- MIXGB$impute(m = 5, maxit = 1,ordinalAsInteger = TRUE))

```



